/***********************************************************************/
/*                                                                     */
/*  FILE        :SemiAutoMahjong.c                                     */
/*  DATE        :Sun, Apr 03, 2016                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :SH7125                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.19).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

//#include "typedefine.h"
#ifdef __cplusplus
//#include <ios>                        // Remove the comment when you use ios
//_SINT ios_base::Init::init_cnt;       // Remove the comment when you use ios
#endif

#include "iodefine.h"
#include <stdio.h>
#include "MTU.h"
#include "Serial.h"

void main(void);
#ifdef __cplusplus
extern "C" {
void abort(void);
}
#endif

#define OKA1 20
#define OKA2 10

void init_CMT(void);
void set_CMT0(int);
void interrpt_CMT0(void);
void delay_ms(int);

void init_LED(void);
void print_seg(void);
void seg_clear(void);
void seg7_H(int);
void seg16_H(int);
void segLED_H(void);
void seg7_1(unsigned char);
void seg7_2(unsigned char);
void seg_point_update(void);
void sw_LED_update(void);

void jarajara(int);

void init_sw(void);
int get_sw(void);

int sw_state_old =0x3F;
int sw_time = 0;

void init_game(void);
char calc_point(int);
int point_table(int,int,char);
void nextgame(char);
void endgame(void);

void finish_disp(void);

void ryukyoku(char);

int seg_num =0;	//7セグ表示用

typedef struct{
	long int _point;		// 持ち点
	int _wind;				// 自風
	char _reach;			// リーチフラグ
	char _tenpai;			// 聴牌フラグ
	int _rank;				// 順位
	long int _pm;			// プラマイ
} Stats;

Stats Player[4];					// 東家～西家
int wind, kyoku, hon, kyotaku;		// 場風、局、本、供託棒

char print_seg7[2][10];
char print_seg16[2][4];
char print_LED;
char print_LED_ten;
int LED_ten = 0;
int sw_LED[6] = {2,2,2,2,2,2};
void sw_LED_one_update(int,int);
void sw_LED_all_update(int,int,int,int,int,int);

void main()
{
	int i,j;
	char buff[256];
	char renchan = 0;

	int sw;

	init_LED();
	init_CMT();
	set_CMT0(1);
	init_SCI1();

	init_MTU();

	init_game();
	seg_point_update();
	sw_LED_update();

	//=====================================
	//スタート
	//=====================================

	init_game();

	// ------------------------------------------------------------------
	// メインループ
	// ------------------------------------------------------------------


	while(1) {
		// スイッチ入力待機
		do {
			sw = get_sw();

			// リーチ処理
			if(sw > -1 && sw < 4) {
				Player[sw]._reach = 1;
				kyotaku++;
			}
		} while(sw == -1);

		// 長押しなら点数計算モードへ
		if(sw > 9 && sw < 14) {
			renchan = calc_point(sw - 10);
			seg_point_update();
		}

		nextgame(renchan);
	}

}

/***********************************************************************
	ゲーム初期化
***********************************************************************/

void init_game(void)
{
	int i;

	for(i = 0; i < 4; i++) {
		Player[i]._point = 25000;		// 持ち点25000
		Player[i]._wind = i;
		Player[i]._reach = 0;
	}

	wind = 0;		// 東場
	kyoku = 1;		// 第1局
	hon = 0;		// 0本場
	kyotaku = 0;	// 供託棒
}

/***********************************************************************
	点数計算
***********************************************************************/

char calc_point(int agari)
{
	int i;
	int hu, han;		// 符点・翻数
	char oya;			// 親フラグ
	char tsumo;			// ロン or ツモ
	int point, hurikomi_oya, hurikomi_ko;			// 和了点、振込点

	int hurikomi;		// 振り込んだ人

	int rotary1, rotary1_old, rotary2, rotary2_old;

	// ロリコンで翻数入力
	rotary1_old = rotary1_get();
	rotary2_old = rotary2_get();

	while(get_sw() == -1) {
		rotary1 = rotary1_get();
		rotary2 = rotary2_get();

		han = (rotary1 - rotary1_old + 2) / 4 + (rotary2 - rotary2_old + 2) / 4;
		if(han < 0) han = 0;

		delay_ms(10);
	}

	// ロリコンで符点入力・振込者決定
	rotary1_old = rotary1_get();
	rotary2_old = rotary2_get();

	do {
		hurikomi = get_sw();

		rotary1 = rotary1_get();
		rotary2 = rotary2_get();

		hu = (rotary1 - rotary1_old + 2) / 4 + (rotary2 - rotary2_old + 2) / 4;
		if(hu < 0) hu = 0;

		delay_ms(10);
	} while(hurikomi == -1 || hurikomi > 3);

	// 0翻0符で流局処理
	if(hu == 0 && han == 0) {
		ryukyoku(oya);
		return oya;
	}

	// 親 or 子
	if(Player[agari]._wind == 0) {
		oya = 1;
	} else {
		oya = 0;
	}

	// 点数テーブル参照
	point = point_table(hu - 1, han - 1, oya);

	// ロン or ツモ
	if(agari == hurikomi) {
		tsumo = 1;
	} else {
		tsumo = 0;
	}

	if(tsumo == 1) {			// ツモの場合
		if(oya == 1) {			// 親のツモ
			hurikomi_ko = point;
			hurikomi_oya = 0;

			hurikomi_ko += 200;
			hurikomi_ko /= 300;
			hurikomi_ko *= 100;
		} else {						// 子のツモ
			hurikomi_oya = point;

			hurikomi_oya += 100;
			hurikomi_oya /= 200;
			hurikomi_oya *= 100;		// 親の支払い

			hurikomi_ko = hurikomi_oya;
			hurikomi_ko += 100;
			hurikomi_ko /= 200;
			hurikomi_ko *= 100;			// 子の支払い
		}

		// 積み棒分を支払い点に加算
		hurikomi_oya += 100 * hon;
		hurikomi_ko += 100 * hon;

		for(i = 0; i < 4; i++) {
			if(i == agari) {		// 和了
				if(oya == 1) {		// 親のツモ
					Player[i]._point += (3 * hurikomi_ko) + (1000 * kyotaku);
				} else {			// 子のツモ
					Player[i]._point += hurikomi_oya + (2 * hurikomi_ko) + (1000 * kyotaku);
				}
			} else {				// 支払い
				if(Player[i]._wind == 0) {							// 親の支払い
					Player[i]._point -= hurikomi_oya;
//					printf("%dの支払い: %d点\n", i, hurikomi_oya);
				} else {											// 子の支払い
					Player[i]._point -= hurikomi_ko;
//					printf("%dの支払い: %d点\n", i, hurikomi_ko);
				}
			}
		}
	} else {			// ロンの場合
		// 積み棒分を支払い点に加算
		hurikomi_oya = point + (300 * hon);

		// 支払い
		Player[hurikomi]._point -= hurikomi_oya;

		// 和了
		Player[agari]._point += hurikomi_oya + (1000 * kyotaku);

//		printf("%dの支払い: %d点\n", hurikomi, hurikomi_oya);
	}

	// 供託棒リセット
	kyotaku = 0;

	// 連荘かな？
	return oya;
}

int point_table(int hu, int han, char oya)
{
	int point_oya[11][4] = {{1000,2000,3900,7700},{0,2400,4800,9600},{1500,2900,5800,11600},{2000,3900,7700,0},{2400,4800,9600,0},{2900,5800,11600,0},{3400,6800,0,0},{3900,7700,0,0},{4400,8700,0,0},{4800,9600,0,0},{5300,10600,0,0}};
	int point_ko[11][4] = {{700,1300,2600,5200},{0,1600,3200,6400},{1000,2000,3900,7700},{1300,2600,5200,0},{1600,3200,6400,0},{2000,3900,7700,0},{2300,4500,0,0},{2600,5200,0,0},{2900,5800,0,0},{3200,6400,0,0},{3600,7100,0,0}};

	int point = 0;

	if(han >= 26) {					// ダブル役満
		if(oya == 1) {
			point = 96000;
		} else {
			point = 64000;
		}
	} else if(han >= 13) {			// 役満
		if(oya == 1) {
			point = 48000;
		} else {
			point = 32000;
		}
	} else if(han >= 11) {			// 三倍満
		if(oya == 1) {
			point = 36000;
		} else {
			point = 24000;
		}
	} else if(han >= 8) {			// 倍満
		if(oya == 1) {
			point = 24000;
		} else {
			point = 16000;
		}
	} else if(han >= 6) {			// 跳満
		if(oya == 1) {
			point = 18000;
		} else {
			point = 12000;
		}
	} else if(han >= 5) {			// 満貫
		if(oya == 1) {
			point = 12000;
		} else {
			point = 8000;
		}
	} else if(han >= 4 && hu >= 3) {
		if(oya == 1) {
			point = 12000;
		} else {
			point = 8000;
		}
	} else if(han >= 3 && hu >= 6) {
		if(oya == 1) {
			point = 12000;
		} else {
			point = 8000;
		}
	} else {						// 満貫未満
		han--;
		if(oya == 1) {
			point = point_oya[hu][han];
		} else {
			point = point_ko[hu][han];
		}
	}

	return point;
}

/***********************************************************************
	次の局へ
***********************************************************************/

void nextgame(char renchan) {
	int i;

	if(renchan == 0) {			// 連荘ではない
		kyoku++;				// 次の局へ
		if(kyoku == 4) {		// 次の場へ
			kyoku = 0;
			wind++;
		}
		hon = 0;				// 積み棒リセット
	} else {					// 連荘
		hon++;					// 積み棒追加
	}

	for(i = 0; i < 4; i++) Player[i]._reach = 0;
}

/***********************************************************************
	精算
***********************************************************************/

void endgame(void) {
	int i, j;
	int tmp;

	// 順位決定
	for(i = 0; i < 4; i++) {
		tmp = 0;
		for(j = 0; j < 4; j++) {
			if(i != j && Player[i]._point > Player[j]._point) tmp++;
		}
		Player[i]._rank = 4 - tmp;
	}

	// 精算
	for(i = 0; i < 4; i++) {
		// 五捨六入
		Player[i]._pm = (Player[i]._point + 400) / 1000;

		// ウマオカ
		switch(Player[i]._rank) {
			case 1:
				Player[i]._pm += (20 + OKA1);
				break;
			case 2:
				Player[i]._pm += OKA2;
				break;
			case 3:
				Player[i]._pm -= OKA2;
				break;
			case 4:
				Player[i]._pm -= OKA1;
				break;
			default:
				break;
		}
	}

	finish_disp();
}

/***********************************************************************
	流局処理
***********************************************************************/

void ryukyoku(char renchan) {
	int i;
	int tenpai = 0;
	char tenpai_f[4];

	// 聴牌人数を入力
	tenpai = 0;

	// リーチ棒を供託に
	for(i = 0; i < 4; i++) {
		if(Player[i]._reach == 1) {
			Player[i]._reach = 0;
			kyotaku++;
		}
	}

	switch(tenpai) {
		case 1:
			for(i = 0; i < 4; i++) {
				if(Player[i]._tenpai == 1) {
					Player[i]._point += 3000;
				} else {
					Player[i]._point -+ 1000;
				}
			}
			break;
		case 2:
			for(i = 0; i < 4; i++) {
				if(Player[i]._tenpai == 1) {
					Player[i]._point += 1500;
				} else {
					Player[i]._point -+ 1500;
				}
			}
			break;
		case 3:
			for(i = 0; i < 4; i++) {
				if(Player[i]._tenpai == 1) {
					Player[i]._point += 1000;
				} else {
					Player[i]._point -+ 3000;
				}
			}
			break;
		default:
			break;
	}

	// 親が聴牌なら本場＋、ノーテンなら次の局へ
	if(Player[0]._wind == 0) {
		nextgame(1);
	} else {
		nextgame(0);
	}

}
//==============================================================================
// C M T
//==============================================================================
void init_CMT(void)
{
	STB.CR4.BIT._CMT = 0;	//モジュールストップ解除
	CMT.CMSTR.BIT.STR0 = 0;	//カウントストップ
	CMT0.CMCSR.BIT.CMIE = 1;//割り込み許可
	CMT0.CMCSR.BIT.CKS = 3;	//分周なし
	CMT0.CMCSR.BIT.CMF = 0;	//フラグクリア
	CMT0.CMCOR = 5; 		//割り込みタイミング25Mhz/512-1
	INTC.IPRJ.BIT._CMT0 = 15;

	CMT.CMSTR.BIT.STR1 = 0;	//カウントストップ
	CMT1.CMCSR.BIT.CMIE = 0;//割り込みしない
	CMT1.CMCSR.BIT.CKS = 0;	//分周なし
	CMT1.CMCSR.BIT.CMF = 0;	//フラグクリア
	CMT1.CMCOR = 3124;		//割り込みタイミング
}

void set_CMT0(int dt)
{
	CMT.CMSTR.BIT.STR0 = dt;//カウントスタート
}

void interrpt_CMT0(void)
{
	CMT0.CMCSR.BIT.CMF = 0;//フラグクリア
	print_seg();
//	get_sw();
	sw_time++;
//	change_LED0();
//	change_LED1();
}

void delay_ms(int ms)
{
	unsigned long j;
	CMT1.CMCSR.BIT.CMF = 0;	//フラグクリア
	CMT1.CMCNT = 0;			//カウンタをゼロに
	CMT.CMSTR.BIT.STR1 = 1;	//カウントスタート

	for(j=0;j<ms;j++)
	{
		while(!CMT1.CMCSR.BIT.CMF);	//1msまつ
		CMT1.CMCSR.BIT.CMF = 0;		//フラグクリア
	}

	CMT.CMSTR.BIT.STR1 = 0;	//カウントストップ
	CMT1.CMCNT = 0;			//カウンタクリア
}

//==============================================================================
// L E D
//==============================================================================

void init_LED(void){
	int i;

	PFC.PACRL4.BIT.PA15MD = 0;//入出力ポート
	PFC.PACRL4.BIT.PA14MD = 0;//入出力ポート
	PFC.PACRL4.BIT.PA13MD = 0;//入出力ポート
	PFC.PACRL4.BIT.PA12MD = 0;//入出力ポート
	PFC.PACRL3.BIT.PA11MD = 0;//入出力ポート
	PFC.PACRL3.BIT.PA10MD = 0;//入出力ポート
	//ロータリーエンコーダ
	PFC.PACRL2.BIT.PA5MD = 0;//入出力ポート
	//3,4はsirial
	PFC.PACRL1.BIT.PA3MD = 0;//入出力ポート
	//3はLED
	PFC.PACRL1.BIT.PA2MD = 0;//入出力ポート
	PFC.PACRL1.BIT.PA1MD = 0;//入出力ポート
	PFC.PACRL1.BIT.PA0MD = 0;//入出力ポート

	PFC.PAIORL.BIT.B15 = 1;//1出力,0入力
	PFC.PAIORL.BIT.B14 = 1;//1出力,0入力
	PFC.PAIORL.BIT.B13 = 1;//1出力,0入力
	PFC.PAIORL.BIT.B12 = 1;//1出力,0入力
	PFC.PAIORL.BIT.B11 = 1;//1出力,0入力
	PFC.PAIORL.BIT.B10 = 1;//1出力,0入力
	//rotary
	PFC.PAIORL.BIT.B5 = 1;//1出力,0入力
	//3,4はsirial
	PFC.PAIORL.BIT.B3 = 1;//1出力,0入力
	//3はLED
	PFC.PAIORL.BIT.B2 = 1;//1出力,0入力
	PFC.PAIORL.BIT.B1 = 1;//1出力,0入力
	PFC.PAIORL.BIT.B0 = 1;//1出力,0入力

	PFC.PBCRH1.BIT.PB16MD = 0;//入出力ポート
	PFC.PBCRL2.BIT.PB5MD = 0;//入出力ポート
	PFC.PBCRL1.BIT.PB3MD = 0;//入出力ポート
	PFC.PBCRL1.BIT.PB2MD = 0;//入出力ポート
	PFC.PBCRL1.BIT.PB1MD = 0;//入出力ポート

	PFC.PBIORH.BIT.B16 = 1;//1出力,0入力
	PFC.PBIORL.BIT.B5 = 1;//1出力,0入力
	PFC.PBIORL.BIT.B3 = 1;//1出力,0入力
	PFC.PBIORL.BIT.B2 = 1;//1出力,0入力
	PFC.PBIORL.BIT.B1 = 1;//1出力,0入力

	PFC.PECRL4.BIT.PE15MD = 0;//入出力ポート
	PFC.PECRL4.BIT.PE14MD = 0;//入出力ポート
	PFC.PECRL4.BIT.PE13MD = 0;//入出力ポート
	PFC.PECRL4.BIT.PE12MD = 0;//入出力ポート
	PFC.PECRL3.BIT.PE11MD = 0;//入出力ポート
	PFC.PECRL3.BIT.PE10MD = 0;//入出力ポート
	PFC.PECRL3.BIT.PE9MD = 0;//入出力ポート
	PFC.PECRL3.BIT.PE8MD = 0;//入出力ポート
	PFC.PECRL2.BIT.PE7MD = 0;//入出力ポート
	PFC.PECRL2.BIT.PE6MD = 0;//入出力ポート
	PFC.PECRL2.BIT.PE5MD = 0;//入出力ポート
	PFC.PECRL2.BIT.PE4MD = 0;//入出力ポート
	PFC.PECRL1.BIT.PE3MD = 0;//入出力ポート
	PFC.PECRL1.BIT.PE2MD = 0;//入出力ポート
	PFC.PECRL1.BIT.PE1MD = 0;//入出力ポート
	PFC.PECRL1.BIT.PE0MD = 0;//入出力ポート

	PFC.PEIORL.BIT.B15 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B14 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B13 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B12 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B11 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B10 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B9 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B8 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B7 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B6 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B5 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B4 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B3 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B2 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B1 = 1;//1出力,0入力
	PFC.PEIORL.BIT.B0 = 1;//1出力,0入力

	//
	for(i=0;i<10;i++)
	{
		print_seg7[i][0]=0xF0;
		print_seg7[i][1]=0xF0;
	}
	for(i=0;i<4;i++)
	{
		print_seg16[i][0]=0xF0;
		print_seg16[i][1]=0xF0;
	}
	print_LED = 0x3F;

}

//====================================================
// 7seg
//====================================================

void print_seg(void)
{
	int i;
	char buff[16];
	seg_clear();

	if(seg_num<10)
	{
		seg7_H(seg_num);
		seg7_1(print_seg7[0][seg_num]);
		seg7_2(print_seg7[1][seg_num]);
	}else if(seg_num<14)
	{
		seg16_H(seg_num-10);
		seg7_1(print_seg16[0][seg_num-10]);
		seg7_2(print_seg16[1][seg_num-10]);
	}else if(seg_num < 15)
	{

		segLED_H();
		seg7_1(0x00);

		if(LED_ten <= 150)
		{

			seg7_1(0x00);
			seg7_2(print_LED|print_LED_ten);
			LED_ten++;
		}
    else if(LED_ten <= 300)
		{

			seg7_1(0x00);
			seg7_2(print_LED);
			LED_ten++;
		}
    else
		{
			seg7_1(0x00);
			seg7_2(print_LED);
			LED_ten = 0;
		}

//		seg7_2(print_LED);
	}else
	{
		seg_num=0;
		seg7_H(seg_num);
		seg7_1(print_seg7[0][seg_num]);
		seg7_2(print_seg7[1][seg_num]);
	}
//	sprintf(buff,"%d\n",seg_num);
//	puts_SCI1(buff);

	seg_num++;
}

void seg_clear()
{
	PA.DRL.WORD &= 0x03D0;
	PB.DR.WORD.L &= 0x0000;
	PE.DRL.WORD &= 0x0000;
}


void seg7_H(int num)
{
	switch(num)
	{
	case 0:
		PA.DRL.BIT.B0 = 1;
		break;
	case 1:
		PA.DRL.BIT.B1 = 1;
		break;
	case 2:
		PA.DRL.BIT.B2 = 1;
		break;
	case 3:
		PA.DRL.BIT.B5 = 1;
		break;
	case 4:
		PE.DRL.BIT.B6 = 1;
		break;
	case 5:
		PE.DRL.BIT.B7 = 1;
		break;
	case 6:
		PB.DR.BIT.B1 = 1;
		break;
	case 7:
		PB.DR.BIT.B2 = 1;
		break;
	case 8:
		PB.DR.BIT.B3 = 1;
		break;
	case 9:
		PB.DR.BIT.B5 = 1;
		break;
	default:
		;
	}
}

void seg16_H(int num)
{
	PE.DRL.WORD |= (0x1<<num);
}

void segLED_H(void)
{
	PA.DRL.BIT.B3 = 1;
}

void seg7_1(unsigned char num)
{
	PA.DRL.BYTE.H |= num&0xFC;
	PE.DRL.BYTE.L |= (num<<4)&0x30;
}

void seg7_2(unsigned char num)
{
	PE.DRL.BYTE.H = num;
}


char trans_seg7[11] = {0x3F,0x30,0x5B,0x79,0x74,0x6D,0x6F,0x3C,0x7F,0x7D,0x63};
/*   PGFE_DCBA
0 0b_0011_1111
1 0b_0011_0000
2 0b_0101_1011
3 0b_0111_1001
4 0b_0111_0100
5 0b_0110_1101
6 0b_0110_1111
7 0b_0011_1100
8 0b_0111_1111
9 0b_0111_1101
o 0b_0110_0011
*/
char trans_seg16[14][2] ={{0x00,0x3F},{0x00,0x06},{0x00,0xDB},{0x00,0xCF},{0x00,0xE6},
						 {0x00,0xED},{0x00,0xFD},{0x00,0x27},{0x00,0xFF},{0x00,0xEF},
						 {0x00,0x79},{0x28,0x36},{0x01,0x8D},{0x09,0x36}};
/*0b_0PNM_LKJH_G2G1FE_DCBA
0 0b_0000_0000___0011_1111
1 0b_0000_0000___0000_0110
2 0b_0000_0000___1101_1011
3 0b_0000_0000___1100_1111
4 0b_0000_0000___1110_0110

5 0b_0000_0000___1110_1101
6 0b_0000_0000___1111_1101
7 0b_0000_0000___0010_0111
8 0b_0000_0000___1111_1111
9 0b_0000_0000___1110_1111

E 0b_0000_0000___0111_1001
W 0b_0010_1000___0011_0110
S 0b_0000_0001___1000_1101
N 0b_0000_1001___0011_0110
*/
void seg_point_update()
{
	int i,num;
	long int player_point[4];

	for(i=0;i<4;i++)
	{
		player_point[i] = Player[i]._point;
	}

	for(i=0;i<5;i++)
	{
		num = player_point[0]%10;
		player_point[0] /= 10;
		if((player_point[0]==0)&&(num==0)&&(i!=0))	//あまりなし、のこりなし、下桁でない
		{
			print_seg7[0][i]=0x00;			//0を表示しない
		}else
		{
			print_seg7[0][i]=trans_seg7[num];//普通
		}

		num = player_point[1]%10;
		player_point[1] /= 10;
		if((player_point[1]==0)&&(num==0)&&(i!=0))	//あまりなし、のこりなし、下桁でない
		{
			print_seg7[0][i+5]=0x00;			//0を表示しない
		}else
		{
			print_seg7[0][i+5]=trans_seg7[num];//普通
		}

		num = player_point[2]%10;
		player_point[2] /= 10;

		if((player_point[2]==0)&&(num==0)&&(i!=0))	//あまりなし、のこりなし、下桁でない
		{
			print_seg7[1][i]=0x00;			//0を表示しない
		}else
		{
			print_seg7[1][i]=trans_seg7[num];//普通
		}

		num = player_point[3]%10;
		player_point[3] /= 10;

		if((player_point[3]==0)&&(num==0)&&(i!=0))	//あまりなし、のこりなし、下桁でない
		{
			print_seg7[1][i+5]=0x00;			//0を表示しない
		}else
		{
			print_seg7[1][i+5]=trans_seg7[num];//普通
		}

	}
/*
	for(i=0;i<2;i++)
	{
		if((print_seg7[i][0]==trans_seg7[0])&&(print_seg7[i][1]==trans_seg7[0]))
		{
			print_seg7[i][0]=trans_seg7[10];
			print_seg7[i][1]=trans_seg7[10];
		}
		if((print_seg7[i][0+5]==trans_seg7[0])&&(print_seg7[i][1+5]==trans_seg7[0]))
		{
			print_seg7[i][0+5]=trans_seg7[10];
			print_seg7[i][1+5]=trans_seg7[10];
		}
	}

	for(i=0;i<4;i++)
	{
		print_seg16[1][i]=trans_seg16[i+10][0];
		print_seg16[0][i]=trans_seg16[i+10][1];
	}
*/

	print_seg16[1][0]=trans_seg16[wind+10][0];
	print_seg16[0][0]=trans_seg16[wind+10][1];

	print_seg16[1][1]=trans_seg16[kyoku][0];
	print_seg16[0][1]=trans_seg16[kyoku][1];

	print_seg16[1][2]=trans_seg16[hon][0];
	print_seg16[0][2]=trans_seg16[hon][1];

	print_seg16[1][3]=trans_seg16[kyotaku][0];
	print_seg16[0][3]=trans_seg16[kyotaku][1];


}

void sw_LED_update(void)
{
	int i;
	print_LED 	= 0;
	print_LED_ten = 0;
	for(i = 0;i<6;i++)
	{
		if(sw_LED[i] == 1)
		{
			print_LED |= (0x1<<i)	;
		}else if(sw_LED[i] == 2)
		{
			print_LED_ten |= (0x1<<i);
		}
	}

}

void sw_LED_one_update(int sw_LED_num,int sw_LED_mode)
{
	int i;
	for(i=0;i<6;i++)
	{
		sw_LED[i] = 0;
	}
	sw_LED[sw_LED_num] =  sw_LED_mode;
	sw_LED_update();
}


void sw_LED_all_update(int sw_LED0,int sw_LED1,int sw_LED2,int sw_LED3,int sw_LED4,int sw_LED5)
{
	sw_LED[0] = sw_LED0;
	sw_LED[1] = sw_LED1;
	sw_LED[2] = sw_LED2;
	sw_LED[3] = sw_LED3;
	sw_LED[4] = sw_LED4;
	sw_LED[5] = sw_LED5;
	sw_LED_update();
}


void jarajara(int dice)
{
	PB.DR.BIT.B16 = dice;
}

void init_sw(void)
{
	sw_state_old = 0x3F;

}
int get_sw(void)
{
	int i;
	char sw_state,and_state,sw_wind;
	char buff[32];

	sw_wind = 0;

//	sprintf(buff,"%d\n\r",sw_time);
//	puts_SCI1(buff);

	if((PF.DRL.BYTE.L&0x3F)!=0x3F)
	{
		return -1;
//		sprintf(buff,"sw = %d\n\r",PF.DRL.BYTE.L&0x3F);
//		puts_SCI1(buff);
//		delay_ms(10);
	}
	sw_state_old = 0x3f;
	sw_time = 0;


	while(1)
	{
		sw_state = (PF.DRL.BYTE.L)&0x3F;
		and_state = sw_state | sw_state_old;


		if(and_state!=0x3F)
		{
			if(sw_time >= 8000)
			{
				sw_wind += 10;
				break;
			}

		}else if(sw_state_old!=0x3F)
		{
			break;
		}else {
			if(sw_time >= 100)
			{
				return -1;
			}
		}

//		sprintf(buff,"%d\t%d\t%d\n\r",and_state,sw_state_old,sw_time);
//		puts_SCI1(buff);

		sw_state_old = sw_state;
		delay_ms(10);

	}
	for(i=0;i<6;i++)
	{
		if(!(sw_state_old&(0x01<<i)))
		{
			sw_wind += i;
			break;
		}
	}

	if((!(sw_state_old&(0x01<<4)))&&(!(sw_state_old&(0x01<<5))))
	{
			sw_wind = 30;
	}

	return sw_wind;

}


void finish_disp(void) {}

#ifdef __cplusplus
void abort(void)
{

}
#endif
